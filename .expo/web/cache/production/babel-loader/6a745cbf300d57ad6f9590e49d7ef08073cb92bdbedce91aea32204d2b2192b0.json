{"ast":null,"code":"import{registerHandler}from'../../handlersRegistry';import RNGestureHandlerModule from'../../../RNGestureHandlerModule';import{filterConfig,scheduleFlushOperations}from'../../utils';import{ghQueueMicrotask}from'../../../ghQueueMicrotask';import{extractGestureRelations,checkGestureCallbacksForWorklets,ALLOWED_PROPS}from'./utils';export function updateHandlers(preparedGesture,gestureConfig,newGestures){gestureConfig.prepare();for(var i=0;i<newGestures.length;i++){var handler=preparedGesture.attachedGestures[i];checkGestureCallbacksForWorklets(handler);if(newGestures[i].handlerTag!==handler.handlerTag){newGestures[i].handlerTag=handler.handlerTag;newGestures[i].handlers.handlerTag=handler.handlerTag;}}ghQueueMicrotask(function(){if(!preparedGesture.isMounted){return;}var shouldUpdateSharedValueIfUsed=preparedGesture.attachedGestures.length!==newGestures.length;for(var _i=0;_i<newGestures.length;_i++){var _handler=preparedGesture.attachedGestures[_i];if(_handler.handlers.gestureId!==newGestures[_i].handlers.gestureId&&(newGestures[_i].shouldUseReanimated||_handler.shouldUseReanimated)){shouldUpdateSharedValueIfUsed=true;}_handler.config=newGestures[_i].config;_handler.handlers=newGestures[_i].handlers;RNGestureHandlerModule.updateGestureHandler(_handler.handlerTag,filterConfig(_handler.config,ALLOWED_PROPS,extractGestureRelations(_handler)));registerHandler(_handler.handlerTag,_handler,_handler.config.testId);}if(preparedGesture.animatedHandlers&&shouldUpdateSharedValueIfUsed){var newHandlersValue=preparedGesture.attachedGestures.filter(function(g){return g.shouldUseReanimated;}).map(function(g){return g.handlers;});preparedGesture.animatedHandlers.value=newHandlersValue;}scheduleFlushOperations();});}","map":{"version":3,"names":["registerHandler","RNGestureHandlerModule","filterConfig","scheduleFlushOperations","ghQueueMicrotask","extractGestureRelations","checkGestureCallbacksForWorklets","ALLOWED_PROPS","updateHandlers","preparedGesture","gestureConfig","newGestures","prepare","i","length","handler","attachedGestures","handlerTag","handlers","isMounted","shouldUpdateSharedValueIfUsed","gestureId","shouldUseReanimated","config","updateGestureHandler","testId","animatedHandlers","newHandlersValue","filter","g","map","value"],"sources":["C:\\Users\\Jorn\\Documents\\hitster\\node_modules\\react-native-gesture-handler\\lib\\module\\handlers\\gestures\\GestureDetector\\updateHandlers.ts"],"sourcesContent":["import { GestureType, HandlerCallbacks } from '../gesture';\nimport { registerHandler } from '../../handlersRegistry';\nimport RNGestureHandlerModule from '../../../RNGestureHandlerModule';\nimport { filterConfig, scheduleFlushOperations } from '../../utils';\nimport { ComposedGesture } from '../gestureComposition';\nimport { ghQueueMicrotask } from '../../../ghQueueMicrotask';\nimport { AttachedGestureState } from './types';\nimport {\n  extractGestureRelations,\n  checkGestureCallbacksForWorklets,\n  ALLOWED_PROPS,\n} from './utils';\n\nexport function updateHandlers(\n  preparedGesture: AttachedGestureState,\n  gestureConfig: ComposedGesture | GestureType,\n  newGestures: GestureType[]\n) {\n  gestureConfig.prepare();\n\n  for (let i = 0; i < newGestures.length; i++) {\n    const handler = preparedGesture.attachedGestures[i];\n    checkGestureCallbacksForWorklets(handler);\n\n    // Only update handlerTag when it's actually different, it may be the same\n    // if gesture config object is wrapped with useMemo\n    if (newGestures[i].handlerTag !== handler.handlerTag) {\n      newGestures[i].handlerTag = handler.handlerTag;\n      newGestures[i].handlers.handlerTag = handler.handlerTag;\n    }\n  }\n\n  // Use queueMicrotask to extract handlerTags, because when it's ran, all refs should be updated\n  // and handlerTags in BaseGesture references should be updated in the loop above (we need to wait\n  // in case of external relations)\n  ghQueueMicrotask(() => {\n    if (!preparedGesture.isMounted) {\n      return;\n    }\n\n    // If amount of gesture configs changes, we need to update the callbacks in shared value\n    let shouldUpdateSharedValueIfUsed =\n      preparedGesture.attachedGestures.length !== newGestures.length;\n\n    for (let i = 0; i < newGestures.length; i++) {\n      const handler = preparedGesture.attachedGestures[i];\n\n      // If the gestureId is different (gesture isn't wrapped with useMemo or its dependencies changed),\n      // we need to update the shared value, assuming the gesture runs on UI thread or the thread changed\n      if (\n        handler.handlers.gestureId !== newGestures[i].handlers.gestureId &&\n        (newGestures[i].shouldUseReanimated || handler.shouldUseReanimated)\n      ) {\n        shouldUpdateSharedValueIfUsed = true;\n      }\n\n      handler.config = newGestures[i].config;\n      handler.handlers = newGestures[i].handlers;\n\n      RNGestureHandlerModule.updateGestureHandler(\n        handler.handlerTag,\n        filterConfig(\n          handler.config,\n          ALLOWED_PROPS,\n          extractGestureRelations(handler)\n        )\n      );\n\n      registerHandler(handler.handlerTag, handler, handler.config.testId);\n    }\n\n    if (preparedGesture.animatedHandlers && shouldUpdateSharedValueIfUsed) {\n      const newHandlersValue = preparedGesture.attachedGestures\n        .filter((g) => g.shouldUseReanimated) // Ignore gestures that shouldn't run on UI\n        .map((g) => g.handlers) as unknown as HandlerCallbacks<\n        Record<string, unknown>\n      >[];\n\n      preparedGesture.animatedHandlers.value = newHandlersValue;\n    }\n\n    scheduleFlushOperations();\n  });\n}\n"],"mappings":"AACA,OAASA,eAAT,KAAgC,wBAAhC,CACA,MAAO,CAAAC,sBAAP,KAAmC,iCAAnC,CACA,OAASC,YAAT,CAAuBC,uBAAvB,KAAsD,aAAtD,CAEA,OAASC,gBAAT,KAAiC,2BAAjC,CAEA,OACEC,uBADF,CAEEC,gCAFF,CAGEC,aAHF,KAIO,SAJP,CAMA,MAAO,SAAS,CAAAC,cAATA,CACLC,eADK,CAELC,aAFK,CAGLC,WAHK,CAIL,CACAD,aAAa,CAACE,OAAd,GAEA,IAAK,GAAI,CAAAC,CAAC,CAAG,CAAb,CAAgBA,CAAC,CAAGF,WAAW,CAACG,MAAhC,CAAwCD,CAAC,EAAzC,CAA6C,CAC3C,GAAM,CAAAE,OAAO,CAAGN,eAAe,CAACO,gBAAhB,CAAiCH,CAAjC,CAAhB,CACAP,gCAAgC,CAACS,OAAD,CAAhC,CAIA,GAAIJ,WAAW,CAACE,CAAD,CAAX,CAAeI,UAAf,GAA8BF,OAAO,CAACE,UAA1C,CAAsD,CACpDN,WAAW,CAACE,CAAD,CAAX,CAAeI,UAAf,CAA4BF,OAAO,CAACE,UAApC,CACAN,WAAW,CAACE,CAAD,CAAX,CAAeK,QAAf,CAAwBD,UAAxB,CAAqCF,OAAO,CAACE,UAA7C,CACD,CACF,CAKDb,gBAAgB,CAAC,UAAM,CACrB,GAAI,CAACK,eAAe,CAACU,SAArB,CAAgC,CAC9B,OACD,CAGD,GAAI,CAAAC,6BAA6B,CAC/BX,eAAe,CAACO,gBAAhB,CAAiCF,MAAjC,GAA4CH,WAAW,CAACG,MAD1D,CAGA,IAAK,GAAI,CAAAD,EAAC,CAAG,CAAb,CAAgBA,EAAC,CAAGF,WAAW,CAACG,MAAhC,CAAwCD,EAAC,EAAzC,CAA6C,CAC3C,GAAM,CAAAE,QAAO,CAAGN,eAAe,CAACO,gBAAhB,CAAiCH,EAAjC,CAAhB,CAIA,GACEE,QAAO,CAACG,QAAR,CAAiBG,SAAjB,GAA+BV,WAAW,CAACE,EAAD,CAAX,CAAeK,QAAf,CAAwBG,SAAvD,GACCV,WAAW,CAACE,EAAD,CAAX,CAAeS,mBAAf,EAAsCP,QAAO,CAACO,mBAD/C,CADF,CAGE,CACAF,6BAA6B,CAAG,IAAhC,CACD,CAEDL,QAAO,CAACQ,MAAR,CAAiBZ,WAAW,CAACE,EAAD,CAAX,CAAeU,MAAhC,CACAR,QAAO,CAACG,QAAR,CAAmBP,WAAW,CAACE,EAAD,CAAX,CAAeK,QAAlC,CAEAjB,sBAAsB,CAACuB,oBAAvB,CACET,QAAO,CAACE,UADV,CAEEf,YAAY,CACVa,QAAO,CAACQ,MADE,CAEVhB,aAFU,CAGVF,uBAAuB,CAACU,QAAD,CAHb,CAFd,EASAf,eAAe,CAACe,QAAO,CAACE,UAAT,CAAqBF,QAArB,CAA8BA,QAAO,CAACQ,MAAR,CAAeE,MAA7C,CAAf,CACD,CAED,GAAIhB,eAAe,CAACiB,gBAAhB,EAAoCN,6BAAxC,CAAuE,CACrE,GAAM,CAAAO,gBAAgB,CAAGlB,eAAe,CAACO,gBAAhB,CACtBY,MADsB,CACd,SAAAC,CAAD,QAAO,CAAAA,CAAC,CAACP,mBADM,IAEtBQ,GAFsB,CAEjB,SAAAD,CAAD,QAAO,CAAAA,CAAC,CAACX,QAFS,GAAzB,CAMAT,eAAe,CAACiB,gBAAhB,CAAiCK,KAAjC,CAAyCJ,gBAAzC,CACD,CAEDxB,uBAAuB,GACxB,CA/Ce,CAAhB,CAgDD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}